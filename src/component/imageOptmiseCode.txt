
// ✅ Step 1: Prepare all hits with default metadata
console.log("now results come...here", result.hits)
// const hiddenImages = JSON.parse(localStorage.getItem("hiddenImages")) || [];

// const rawHits = result.hits
//   .filter((img) => !hiddenImages.includes(img.id)) // 🚫 Skip hidden before first paint
//   .map((img, i) => ({
//     ...img,
//     _orderIndex: images.length + i,
//     _category: content[index],
//     imageColor: "#ffffff",
//     isValidating: true,
//   }));

// // ✅ Step 2: Immediately show images (fast paint, no delay)
// setImages((prevImages) => {
//   const existingIds = new Set(prevImages.map((img) => img.id));
//   const uniqueNewImages = rawHits.filter((img) => !existingIds.has(img.id));
//   return [...prevImages, ...uniqueNewImages];
// });
// console.log("now results printed...here", result.hits)

// // ✅ Step 3: Background validation + cleanup (non-blocking)
// requestIdleCallback(async () => {
//   try {
//     const batchSize = 10;
//     let validImages = [];

//     for (let i = 0; i < rawHits.length; i += batchSize) {
//       const batch = rawHits.slice(i, i + batchSize);

//       const validatedBatch = await Promise.all(
//         batch.map(async (img) => {
//           const isValid = await isImageUrlValid(img.webformatURL);
//           // return isValid ? img : null;
//           return isValid ? { ...img, isValidating: false } : null;
//         })
//       );

//       validImages = validImages.concat(validatedBatch.filter(Boolean));
//     }

//     // ✅ Merge validated, still excluding hidden ones
//     const filteredImages = validImages.filter(
//       (img) => !hiddenImages.includes(img.id)
//     );

//     setImages((prevImages) => {
//       const existingIds = new Set(prevImages.map((img) => img.id));
//       const uniqueNewImages = filteredImages.filter(
//         (img) => !existingIds.has(img.id)
//       );
//       return [...prevImages, ...uniqueNewImages];
//     });
//     console.log("now results filtered...here", result.hits)
//   } catch (err) {
//     console.error("Background validation failed:", err);
//   } finally {
//     // ✅ Cleanup loaders and tracking states
//     setloader(false);
//     hasLoadedOnce.current = true; // ✅ Mark as loaded
//     setTrakImage(false);
//     if (bottomLoader) setBottomLoader(false);
//   }
// });

------------------------------------------------------------------------------------------------------------------------------

async function getSavedByOthersImages() {
  const url = `https://pixabay.com/api/?key=45283300-eddb6d21a3d3d06f2a2381d7d&order=popular&editors_choice=true&image_type=photo&per_page=20`;

  const cacheKey = "saved-by-others";
  const cacheCatch = await getCache(cacheKey);

  if (cacheCatch) {
    setupImageOnPage(cacheCatch); // reuse your same image setup logic
    return;
  }

  try {
    const response = await fetch(url);
    const result = await response.json();
    setCache(cacheKey, result);
    setupImageOnPage(result);
  } catch (error) {
    console.error("Error fetching saved-by-others images:", error);
  }
}

-----------------------------------------------------------------------------------------------------------------


  

// ✅ Step 1: Prepare all hits with default metadata
console.log("now results come...here", result.hits);
const hiddenImages = JSON.parse(localStorage.getItem("hiddenImages")) || [];

const rawHits = result.hits
  .filter((img) => !hiddenImages.includes(img.id)) // 🚫 Skip hidden before first paint
  .map((img, i) => ({
    ...img,
    _orderIndex: images.length + i,
    _category: content[index],
    imageColor: "#ffffff",
    isValidating: true,
  }));

// ✅ Step 2: Instantly paint all (fast visual feedback)
setImages((prevImages) => {
  const existingIds = new Set(prevImages.map((img) => img.id));
  const uniqueNewImages = rawHits.filter((img) => !existingIds.has(img.id));
  return [...prevImages, ...uniqueNewImages];
});

// ✅ Step 3: Split into two batches (fast first + deferred)
const immediateBatch = rawHits.slice(0, 8); // first few images = top of viewport
const deferredBatch = rawHits.slice(8);

(async () => {
  try {
    // 🚀 Validate first batch immediately (visible part)
    const validatedImmediate = await Promise.all(
      immediateBatch.map(async (img) => {
        const isValid = await isImageUrlValid(img.webformatURL);
        return isValid ? { ...img, isValidating: false } : null;
      })
    );

    const validImmediate = validatedImmediate.filter(Boolean);
    setImages((prev) => {
      const ids = new Set(prev.map((i) => i.id));
      const unique = validImmediate.filter((i) => !ids.has(i.id));
      return prev.map((img) =>
        validImmediate.some((v) => v.id === img.id)
          ? { ...img, isValidating: false }
          : img
      );
    });

    // ⚙️ Step 4: Validate remaining batch in idle time (non-blocking)
    requestIdleCallback(async () => {
      try {
        const batchSize = 10;
        let validImages = [];

        for (let i = 0; i < deferredBatch.length; i += batchSize) {
          const batch = deferredBatch.slice(i, i + batchSize);

          const validatedBatch = await Promise.all(
            batch.map(async (img) => {
              const isValid = await isImageUrlValid(img.webformatURL);
              return isValid ? { ...img, isValidating: false } : null;
            })
          );

          validImages = validImages.concat(validatedBatch.filter(Boolean));
        }

        // ✅ Merge validated (still excluding hidden)
        const filteredImages = validImages.filter(
          (img) => !hiddenImages.includes(img.id)
        );

        setImages((prev) => {
          const ids = new Set(prev.map((i) => i.id));
          const unique = filteredImages.filter((i) => !ids.has(i.id));
          return prev.map((img) =>
            filteredImages.some((v) => v.id === img.id)
              ? { ...img, isValidating: false }
              : img
          );
        });
      } catch (err) {
        console.error("Deferred validation failed:", err);
      } finally {
        // ✅ Cleanup loaders and flags
        setloader(false);
        hasLoadedOnce.current = true;
        setTrakImage(false);
        if (bottomLoader) setBottomLoader(false);
      }
    });
  } catch (err) {
    console.error("Immediate validation failed:", err);
  }
})();
