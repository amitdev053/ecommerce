
// âœ… Step 1: Prepare all hits with default metadata
console.log("now results come...here", result.hits)
// const hiddenImages = JSON.parse(localStorage.getItem("hiddenImages")) || [];

// const rawHits = result.hits
//   .filter((img) => !hiddenImages.includes(img.id)) // ðŸš« Skip hidden before first paint
//   .map((img, i) => ({
//     ...img,
//     _orderIndex: images.length + i,
//     _category: content[index],
//     imageColor: "#ffffff",
//     isValidating: true,
//   }));

// // âœ… Step 2: Immediately show images (fast paint, no delay)
// setImages((prevImages) => {
//   const existingIds = new Set(prevImages.map((img) => img.id));
//   const uniqueNewImages = rawHits.filter((img) => !existingIds.has(img.id));
//   return [...prevImages, ...uniqueNewImages];
// });
// console.log("now results printed...here", result.hits)

// // âœ… Step 3: Background validation + cleanup (non-blocking)
// requestIdleCallback(async () => {
//   try {
//     const batchSize = 10;
//     let validImages = [];

//     for (let i = 0; i < rawHits.length; i += batchSize) {
//       const batch = rawHits.slice(i, i + batchSize);

//       const validatedBatch = await Promise.all(
//         batch.map(async (img) => {
//           const isValid = await isImageUrlValid(img.webformatURL);
//           // return isValid ? img : null;
//           return isValid ? { ...img, isValidating: false } : null;
//         })
//       );

//       validImages = validImages.concat(validatedBatch.filter(Boolean));
//     }

//     // âœ… Merge validated, still excluding hidden ones
//     const filteredImages = validImages.filter(
//       (img) => !hiddenImages.includes(img.id)
//     );

//     setImages((prevImages) => {
//       const existingIds = new Set(prevImages.map((img) => img.id));
//       const uniqueNewImages = filteredImages.filter(
//         (img) => !existingIds.has(img.id)
//       );
//       return [...prevImages, ...uniqueNewImages];
//     });
//     console.log("now results filtered...here", result.hits)
//   } catch (err) {
//     console.error("Background validation failed:", err);
//   } finally {
//     // âœ… Cleanup loaders and tracking states
//     setloader(false);
//     hasLoadedOnce.current = true; // âœ… Mark as loaded
//     setTrakImage(false);
//     if (bottomLoader) setBottomLoader(false);
//   }
// });

------------------------------------------------------------------------------------------------------------------------------

async function getSavedByOthersImages() {
  const url = `https://pixabay.com/api/?key=45283300-eddb6d21a3d3d06f2a2381d7d&order=popular&editors_choice=true&image_type=photo&per_page=20`;

  const cacheKey = "saved-by-others";
  const cacheCatch = await getCache(cacheKey);

  if (cacheCatch) {
    setupImageOnPage(cacheCatch); // reuse your same image setup logic
    return;
  }

  try {
    const response = await fetch(url);
    const result = await response.json();
    setCache(cacheKey, result);
    setupImageOnPage(result);
  } catch (error) {
    console.error("Error fetching saved-by-others images:", error);
  }
}
